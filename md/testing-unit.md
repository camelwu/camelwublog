# 前端单元测试

前端测试工具也和前端的开发框架一样重要。其中常见的工具大致可分为测`试框架`、`断言库`、`测试覆盖率工具`等几类。

正式开始学习之前，先大概介绍下它们：

## 测试框架
测试框架的作用是提供一些方便的语法来描述测试用例，以及对用例进行分组。

测试框架分为两种： TDD （测试驱动开发）和 BDD （行为驱动开发），两者间的区别主要是一些语法上的不同，其中 BDD 提供了提供了可读性更好的用例语法。常见的测试框架有 [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/) 以及 [Jest](https://jestjs.io/docs/zh-Hans/getting-started) 。

### 断言库

断言库主要提供语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有：
#### better-assert
+ C-style TDD 断言库
+ 由TJ Holowaychuk 发起

API 样例
```
assert('tobi' == user.name)
assert('number' == typeof user.age)
```

#### should.js
+ BDD 风格断言库
+ 同样由 TJ Holowaychuk 发起

API样例
```
foo.should.be()
bar.should.have()
foo.should.bot.be()
```

#### expect.js
+ 追求极简的 BDD 风格断言库
+ 基于 should.js 简化

API样例
```
expect(foo).to.be()
expect(foo).to.eql()
expect(foo).to.be.a()
expect(foo).not.to.be.an()
```

#### chai
+ BDD/TDD 双模 ，同时支持 assert / should / expect 三种风格的断言库
+ 强大插件机制
+ chai-webdriver

API样例:
```
should style: foo.should.be.a()
expect style: expect(foo).to.be.a()  // 近Jasmine风格
assert style: assert.equal(foo, 'bar')
```
#### 其他
+ Jasmine.js 测试框架中的断言库十分类似 Chai expect和 expect.js (Jasmine历史比前两者悠久)
+ assert 风格最保守
+ should 风格需要修改prototype 最为激进
+ 不考虑Node环境的话，Jasmine.js是好选择

### 测试覆盖率工具
用于统计测试用例对代码的测试情况，生成相应的报表，比如`istanbul`，后续我们会根据实例进行说明。

## 为什么选择Jest框架
当开始开发新前端项目的时候，我经常会问自己两个问题：“我应该用那一个 JavaScript 单元测试框架呢？” 和 “我应该花时间去添加测试代码吗？”
### Jasmine, Mocha, Jest 的比较
有效的单元测试是减少你软件错误的一部分。要让你的单元测试更健壮还需要用到一些 JavaScript 调试小技巧。

#### Jasmine

最受欢迎的 Javascript 单元测试框架之一，Jasmine提供所有你所需要的功能并且开箱即用。

Jasmine 带有 assertions(断言)，spies (用来模拟函数的执行环境)，和 mocks (mock 工具)，非常完美地配备几乎是你开始写单元测试时需要的所有东西。Jasmine 初始化设置简单同时如果你需要一些单元功能的时候你仍然可以加一些库进来 (括号内容：译者注)
全局性使它更容易在你的应用中立即开始测试。虽然我并不喜欢全局性，但是和 Jasmine 提供给开发者全部需要的开箱即用功能，并没有太多的不一致的地方
我发现独立版本能让它更容易去理解所有东西是怎样设置的，并能让你能立刻开始使用它
时至今日已经能和 Angular 1 或者 Angular 2 或者更多流行库组合使用了

> 我对 Jasmine 的看法
我不是占有全局变量环境的粉丝，所以 Jasmine 会在我的小本子上面丢些分。在另一方面，它有很多很好的即开即用功能。它看上去会显得稍微 “老些” 比起其它在这列表的框架，但是这并不是一件坏事，其它框架可能遇到的痛点，意味着它们更应更容易被解决。

#### Mocha
作为可以说是使用最多的库，Mocha 是一个灵活的库，提供给开发者的只有一个基础测试结构。然后其它功能性的功能如 assertions， spies，mocks，和像它们一样的其它功能需要引用添加其它库/插件来完成。

如果你想要更灵活的配置，导入你特定需要的库，那么 Mocha 额外的安装与所需要的配置是你必须要看的
不幸的是，上面的观点确实还存在问题，它必须导入额外的库来实现 assertions (译者注:断言功能)。如果不是长时间使用，这确实意味着比其它的更难一点去设置. 他们说，设置通常只是一次性操作，但是我更喜欢去做一个 “单一来源的事实” (文档) 代替在文档间跳来跳去地设置
Mocha 导入测试结构作为全局变量，省去你的时间你不再需要 include 或者请求它在每个文件中。缺点是无论如何那些插件还是要你使用 require 导入到里面，这会导致不一致。

> 我对 Mocha 的看法
可扩展性和数种不同配置 Mocha 的方式另我印象深刻。必须去学习 Mocha，然后也必须去学习你选择的 assertion 库这的确吓到了我不少。灵活性在于它的 assertions，spies 和 mocks 带给它的高收益。
Jest

#### Jest

对于小型项目来说你可能在开始的时候不用过多担心，而性能的提高对于希望全天 持续部署 的大型应用 app 来说是非常之好的
而开发人员主要是用 Jest 去测试 React 应用，Jest 可以很容易地集成到其它应用程序中充许你使用更独特的特性在其它地方
快照测试是一个非常好用的工具去确保你的应用 UI 不会有超出预期的错误在产品发布替换的期间发生。虽然大部分功能专门设计都是使用在 React 上，但是它也能在其它框架上面如果你能找到合适的插件
不像在这列表上其它的库，Jest 有着很广阔的 API，除非你真的需要一些额外的功能需求，不然不需要你导入额外的库
随着他们的每一次更新Jest 继续大幅改进功能

> 我对 Jest 的看法
在全局变量是一个缺点，Jest 是一个不断发展功能强大的库。它有很多易于理解的文档帮助学习，并且支持各种不同环境，当构建项目的时候这些环境都显示很棒。
我应该选那一个 JavaScript 单元测试框架？
在我研究了一些不同的框架之后，我得出一个结论，框架并非都是非黑即白的。
大部分框架最终都会(Mocha 除外)在一天结束的时候提供给你你所需要的东西，这是一个测试环境同确保给出的 X -> Y 总回被返回的机制，有几个会简单的会给你更多 “华而不实的东西。”
你在选择他们的时候你自己应该充满自信，而我的选择取决于你和你特定项目想要的和需要的。


## 总结
在 Jest 未面世的时候， Mocha + Chai 的测试方案是最流行，容易上手的。如果你有一个大项目, 或者想快速开始不需要太多配置，那么 Jest 将会是一个很好的选择。

### 无缝迁移
如果你的项目中已经使用了别的测试框架，比如 Mocha，有一个第三方工具jest-codemods可以自动把用例迁移成 Jest 的用例，降低了迁移成本。

