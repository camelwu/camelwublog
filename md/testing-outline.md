# 前端
前端是一种技术问题较少，工程问题较多的软件开发领域；常见问题如下：

大体量：多功能、多页面、多状态、多系统；
大规模：多人甚至多团队合作开发；
高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载

要开发一款完整的Web应用时，一般经历下面几个阶段：

+ 第一阶段：库/框架 选型

前端工程建设的第一项任务就是根据项目特征进行技术选型。  
js：prototype，mootools，jQuery，bootstrap，underscore+backbone，zepto，knockout，angular，react，vue  
css：animate.css，normalize.css  

基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery + bootstrap都很正常吧，React/Vue 等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。  

+ 第二阶段：构建工具

`开发框架`选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。现在的主流框架基本都自带脚手架或构建工具  

目前还有采用[grunt](https://www.gruntjs.net/)和[gulp](https://www.gulpjs.com/)，对资源进行压缩合并和打包的项目。当然，这两个技术已经更新换代很久。现在流行的是[webpack](https://webpack.js.org/)  

+ 第三阶段：开发（JS/CSS模块化）

从Yahoo最早提出命名空间开始，到AMD|CMD模块开发，requireJs，seaJs，grunt|gulp，webpack等可以看到前端模块化技术的演进。分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。

不管将来是否要复用某段代码，请将其分治为一个模块。现在Js[模块化](./Modular.md)方案很多，AMD|CMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、styls、postcss等预处理器的import/mixin特性支持下实现的。

+ 第四阶段：测试（自动化 & 人工）  
人工测试这里就不多说，大部分前端同学现在都是这样的工作流：  
```
# RD ：开发，对接API等
prd(原型) -> UX(ui ue) -> RD -> Testing
                          |         |
                            resolve（修复）
                               |
                              done （完成）
                               |
                            deploy（publish）部署上线
```

+ 第五阶段：部署
```
build -> deploy -> publish
构建打包，部署到测试或UAT服务器，发布到正式服务器
```
## 为什么要进行测试？
+ 测试可以确保得到预期的结果  
+ 作为现有代码行为的描述  
+ 促使开发者写可测试的代码，一般可测试的代码可读性也会高一点  
+ 如果依赖的组件有修改，受影响的组件能在测试中发现错误  

## 前端自动化测试，值不值得？
近几年前端工程化的发展风起云涌，但是前端自动化测试这块内容大家却似乎不太重视。虽然项目迭代过程中会有专门的测试人员进行测试，但等他们来进行测试时，代码已经开发完成的状态。与之相比，如果我们在开发过程中就进行了测试（直接采用 TDD 开发模式、或者针对既有的模块写用例），会有如下的好处：

+ 保障代码质量和功能的实现的完整度
+ 提升开发效率，在开发过程中进行测试能让我们提前发现 bug ，此时进行问题定位和修复的速度自然比开发完再被叫去修 bug 要快许多
+ 便于项目维护，后续任何代码更新也必须跑通测试用例，即使进行重构或开发人员发生变化也能保障预期功能的实现

当然，凡事都有两面性，好处虽然明显，却并不是所有的项目都值得引入测试框架，毕竟维护测试用例也是需要成本的。对于一些需求频繁变更、复用性较低的内容，比如活动页面，让开发专门抽出人力来写测试用例确实得不偿失。

而那些适合引入测试场景大概有这么几个：  
+ 需要长期维护的项目。它们需要测试来保障代码可维护性、功能的稳定性
+ 较为稳定的项目、或项目中较为稳定的部分。给它们写测试用例，维护成本低
+ 被多次复用的部分，比如一些通用组件和库函数。因为多处复用，更要保障质量
+ 接手一个过去的项目（历史遗留或其它团队），想进行改造

所以，在提交给测试的这个环节，工程师如果能保证代码`可用性`和`质量`那么会为整个项目节省大量的人力和时间`成本`；本视频主要分享的是自动化测试。下面先来介绍一些测试的前置知识。

## 测试类型

+ 单元测试：  
指的是以原件的单元为单位，对软件进行测试。单元可以是一个函数，也可以是一个模块或一个组件，基本特征就是只要输入不变，必定返回同样的输出。一个软件越容易些单元测试，就表明它的模块化结构越好，给模块之间的耦合越弱。React的组件化和函数式编程，天生适合进行单元测试

+ 功能测试：  
相当于是黑盒测试，测试者不了解程序的内部情况，不需要具备编程语言的专门知识，只知道程序的输入、输出和功能，从用户的角度针对软件界面、功能和外部结构进行测试，不考虑内部的逻辑

+ 集成测试：  
在单元测试的基础上，将所有模块按照设计要求组装成子系统或者系统，进行测试

+ 冒烟测试：  
在正式全面的测试之前，对主要功能进行的与测试，确认主要功能是否满足需要，软件是否能正常运行

自动化测试一般使用场景是在`单元测试`这个部分。根据项目类型和特点的不同，我们在开发自动化测试的时候又分为两种开发模式

## 开发模式

+ TDD：  
测试驱动开发，英文为Testing Driven Development，强调的是一种开发方式，以测试来驱动整个项目，即先根据接口完成测试编写，然后在完成功能是要不断通过测试，最终目的是通过所有测试

+ BDD：  
行为驱动测试，英文为Behavior Driven Development，强调的是写测试的风格，即测试要写的像自然语言，让项目的各个成员甚至产品都能看懂测试，甚至编写测试

`TDD`和`BDD`有各自的使用场景，BDD一般偏向于系统功能和业务逻辑的自动化测试设计；而TDD在快速开发并测试功能模块的过程中则更加高效，以快速完成开发为目的。

下一节，我们将分享单元测试。
